# Spec: Raytracer Module and Image Generation

**Reference:** ["Ray Tracing in One Weekend"](https://raytracing.github.io/books/RayTracingInOneWeekend.html)

**Related Specs:** `specs/vec3.md`, `specs/ray.md`, `specs/hittable.md`, `specs/sphere.md`, `specs/camera.md`

**Goal:** Define the main entry point (`src/raytracer.ts`) for generating the raytraced image. This module is responsible for setting up the scene, configuring the camera, invoking the rendering process, and converting the output to a PNG buffer.
**Motivation:** Provide a high-level function that orchestrates the setup and rendering process, separating the core rendering logic (now in `Camera`) from the scene definition and final image encoding.

## Image Generation Function (`src/raytracer.ts`)

**Dependencies:** Utilizes `Vec3`, `Point3`, `Color` from `src/vec3.ts`, `Sphere` from `src/sphere.ts`, `HittableList` from `src/hittableList.ts`, and `Camera` from `src/camera.ts`. Also uses the external `sharp` library for PNG encoding.

### 1. `generateImageBuffer`

*   **Signature:** `async function generateImageBuffer(imageWidth: number = 400, verbose: boolean = false): Promise<Buffer>`
*   **Purpose:** Orchestrates the image generation process.
*   **Image Setup:**
    *   Calculates image height based on the provided `imageWidth` and a fixed `aspectRatio` (16:9).
    *   Determines the number of channels (currently 4 for RGBA, matching `Camera.render`'s output buffer).
    *   Allocates a `Uint8ClampedArray` buffer (`pixelData`) to hold the raw pixel data generated by the camera.
*   **World Setup:**
    *   Creates a `HittableList` instance (`world`).
    *   Adds scene objects (e.g., `Sphere` instances) to the `world`.
*   **Camera Setup:**
    *   Defines camera parameters: vertical field-of-view (`vfov`), look-from point (`lookfrom`), look-at point (`lookat`), and view-up vector (`vup`).
    *   Creates a `Camera` instance, passing the image dimensions, camera parameters, and the `world` object.
*   **Rendering:**
    *   Optionally logs a start message to `stderr` if `verbose` is true.
    *   Calls the `camera.render(pixelData, verbose)` method, passing the allocated buffer and the verbose flag. This performs the core raytracing and populates `pixelData`.
    *   Optionally logs a completion message to `stderr` if `verbose` is true.
*   **PNG Conversion:**
    *   Checks if the `pixelData` buffer is empty.
    *   Converts the `Uint8ClampedArray` (`pixelData`) to a Node.js `Buffer`.
    *   Uses the `sharp` library to encode the raw pixel `Buffer` into a PNG format.
    *   Returns the resulting PNG `Buffer` as a `Promise`.

## MCP Integration & Setup (`src/index.ts`)

*   (This section remains largely the same as it describes the MCP tool definition, which still uses `generateImageBuffer`)

### 1. MCP Tool Definition (`src/index.ts`)

*   **Name:** `raytrace`
*   **Purpose:** Provides an MCP interface to trigger the image generation process defined in `generateImageBuffer`.
*   **Parameters:**
    *   `verbose: boolean` (optional, default: `false`) - If true, enables progress logging during image generation (passed down to `generateImageBuffer` and `camera.render`).

### 2. Output Format

*   The `raytrace` tool must return the generated image data.
*   **Encoding:** `generateImageBuffer` uses the `sharp` library to encode the raw pixel data buffer into PNG format.
*   **MCP Response:** The tool's response must be an MCP `content` object with:
    *   `type: 'image'`
    *   `data`: The base64-encoded string of the PNG image buffer returned by `generateImageBuffer`.
    *   `mimeType: 'image/png'`.

### 3. Progress Reporting

*   **Triggering:** Progress reporting is triggered by the `verbose` flag passed to the `raytrace` tool.
*   **Implementation:** The actual logging happens within `generateImageBuffer` (start/end messages) and `camera.render` (scanline progress), controlled by the `verbose` flag passed down.
*   **Destination:** All progress messages must be written to `stderr`.

### 4. Language

*   All implementation code must be in Typescript.

**Future Considerations:**

*   Adding more complex scene setup logic to `generateImageBuffer` or external scene files.
*   Adding parameters to the `raytrace` tool (e.g., image dimensions, scene selection, camera parameters).
*   Implementing subsequent chapters of the raytracing guide (e.g., materials, anti-aliasing) primarily within the `Camera` class or new related modules.